import pandas as pd
from rdkit import Chem

# Load the CSV file containing the generated SMILES strings
df = pd.read_csv(file_path)

# Assuming the column containing SMILES strings is named 'smiles'
smiles_list = df['SMILES']

# Function to convert SMILES to molecule object
def smiles_to_molecule(smiles):
    return Chem.MolFromSmiles(smiles)

# Convert SMILES to Morgan fingerprint
def smiles_to_fingerprint(smiles):
    mol = smiles_to_molecule(smiles)
    if mol:
        return AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=2048)
    return None

# Compute Morgan fingerprints for FCD
def get_fingerprints(smiles_list):
    fps = []
    for smi in smiles_list:
        mol = smiles_to_molecule(smi)
        if mol:
            fp = AllChem.GetMorganFingerprintAsBitVect(mol, 2, nBits=2048)
            arr = np.zeros((1,))
            DataStructs.ConvertToNumpyArray(fp, arr)
            fps.append(arr)
    return np.array(fps)

# Fréchet Distance between fingerprint distributions
def frechet_distance(mu1, sigma1, mu2, sigma2):
    diff = mu1 - mu2
    covmean, _ = sqrtm(sigma1 @ sigma2, disp=False)
    if np.iscomplexobj(covmean):
        covmean = covmean.real
    return np.dot(diff, diff) + np.trace(sigma1 + sigma2 - 2 * covmean)

# Validity: % of valid SMILES
def calculate_validity(smiles_list):
    valid_smiles = [smiles for smiles in smiles_list if smiles_to_molecule(smiles) is not None]
    validity_percentage = len(valid_smiles) / len(smiles_list) * 100
    return validity_percentage, valid_smiles

# Uniqueness: % of unique SMILES
def calculate_uniqueness(smiles_list):
    unique_smiles = set(smiles_list)
    uniqueness_percentage = len(unique_smiles) / len(smiles_list) * 100
    return uniqueness_percentage, unique_smiles

# Novelty: % of generated SMILES not in training
def calculate_novelty(generated_smiles, training_smiles):
    training_set = set(training_smiles)
    novelty_count = sum(1 for smiles in generated_smiles if smiles not in training_set)
    novelty_percentage = novelty_count / len(generated_smiles) * 100
    return novelty_percentage

# Internal diversity using 1 - Tanimoto similarity
def calculate_internal_diversity(smiles_list):
    fingerprints = [smiles_to_fingerprint(smiles) for smiles in smiles_list]
    valid_fingerprints = [fp for fp in fingerprints if fp is not None]

    if len(valid_fingerprints) < 2:
        return 0

    similarities = []
    for i in range(len(valid_fingerprints)):
        for j in range(i + 1, len(valid_fingerprints)):
            similarity = DataStructs.TanimotoSimilarity(valid_fingerprints[i], valid_fingerprints[j])
            similarities.append(similarity)

    average_similarity = np.mean(similarities)
    diversity = 1 - average_similarity
    return diversity

# FCD: Fréchet ChemNet Distance
def calculate_fcd(generated_smiles, training_smiles):
    generated_fps = get_fingerprints(generated_smiles)
    training_fps = get_fingerprints(training_smiles)

    mu_generated = np.mean(generated_fps, axis=0)
    sigma_generated = np.cov(generated_fps, rowvar=False)

    mu_training = np.mean(training_fps, axis=0)
    sigma_training = np.cov(training_fps, rowvar=False)

    return frechet_distance(mu_generated, sigma_generated, mu_training, sigma_training)

validity_percentage_idc, valid_generated_smiles_idc = calculate_validity(generated_smiles_idc)
print(f"IDC Validity: {validity_percentage_idc:.2f}%")

uniqueness_percentage_idc, unique_generated_smiles_idc = calculate_uniqueness(generated_smiles_idc)
print(f"IDC Uniqueness: {uniqueness_percentage_idc:.2f}%")

novelty_percentage_idc = calculate_novelty(generated_smiles_idc, training_smiles_idc)
print(f"IDC Novelty: {novelty_percentage_idc:.2f}%")

internal_diversity_idc = calculate_internal_diversity(valid_generated_smiles_idc)
print(f"IDC Internal Diversity: {internal_diversity_idc:.4f}")

fcd_idc = calculate_fcd(generated_smiles_idc, training_smiles_idc)
print(f"IDC Fréchet Distance (FCD): {fcd_idc:.4f}")
